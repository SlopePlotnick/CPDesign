# 验收

## 活动记录设计

|          ...（参数）           |
| :----------------------------: |
|            返回地址            |
| 静态链（反映形式上的嵌套关系） |
|      老sp（反映调用关系）      |

> 老sp：指向调用子过程前的最新活动基地址
>
> 静态链：指向直接外层最新活动记录的基地址 用来访问非局部数据
>
> 活动记录中没有参数个数 每个活动记录中 相对地址从0开始

## 符号表设计

+ ***符号表项结构体***

  ```c++
  // 符号表表项类
  class symbol {
  public:
      string name; // 标识符名称
      int type; // 0: const 1: var 2: procedure
      int value; // 值 在不同类型中有不同的含义
      int level; // 层次
      int addr; // 相对地址
      int size; // 保存procrdure类型的参数个数
      int num; // 变量在程序中出现的次数 便于内存优化
  };
  ```

+ ***各类型参数有效性及参数含义***

  > 此处以举例的方式说明 无意义的位置用x表示

  |   name   |   type    |         value          | level |   addr   |   size   |   num    |
  | :------: | :-------: | :--------------------: | :---: | :------: | :------: | :------: |
  | 常量名称 |   CONST   |        常量数值        | 层次  |    x     |    x     |    x     |
  | 变量名称 |    VAR    |         变量值         | 层次  | 相对地址 |    x     | 出现次数 |
  | 过程名称 | PROCEDURE | 过程所处的首指令的地址 | 层次  |    x     | 参数个数 |    x     |

## 参数传递的设计

+ ***指令设计***

  用指令`STO -1 a`来表示参数的传递

  其中`-1`是一个标识 用来与正常的STO指令作区分

  其中`a`标识的是传递的参数在其所处的活动记录中的相对偏移量 但实际操作时这里的`a`并没有被使用到 具体原因见下面

+ ***指令执行***

  当解释器遇到`STO`指令且层差为`-1`时 视为参数传递指令 执行以下操作：

  > 将当前栈顶的值复制到其上方偏移量为3的位置 然后将当前栈顶元素出栈

  该操作实际上是把需要传递的参数的值放到了被调用函数的活动记录中的正确位置 从而完成了参数传递

## RED指令设计

与设计教学要求报告给出的假想代码不同 此处用`RED 0 0`表示读一个数存入栈顶 随后用`STO`指令将读入的数存入变量

---

## 验收要求

1. 符号表处理
2. 参数的传递 注意不能浪费空间
3. 递归调用 嵌套调用
4. 非局部变量的访问
5. 回填
6. 解释执行
7. 报告
